[sp.slide-title{ lopdfの話 }]
[sp.event-title{ Rust LT #2 〜いま使う！Rust〜 }]
section.page.first-page {
h1: lopdfの話
h2: 2018-08-01 Rust LT #2 〜いま使う！Rust〜
h3: 小嶋智
}

# 自己紹介

* プログラマ
* RubyやC++を書きます
* テキスト処理や電子出版の周辺を漂っています
* Rust歴3ヶ月程度

image.fig-20(img/profile.png, プロフィール画像): 

#(t) 話す内容

##(p)  lopdf
* PDFライブラリ
* 製品で使った話をします

#(t) 背景 

##(t) 対象の製品

section.page {
h3.invisible: VeraType by Trim-marks

image.fig-80(img/versatype.png, VersaType説明): [l(https://trim-marks.com/){https://trim-marks.com/}]

}

###(p) VersaType

* HTML/CSSをページ組版するエンジン
** JS製

###(p) VersaType Converter

* HTML/CSSをPDFに変換
* jsエンジン + 組み込み用Chromium
* Win/Linux/macOSのバイナリ

##(p) なぜPDF処理(1) 

* PDF生成はChromium任せ
* PDF出力をもっと強くしたい
* 後処理 vs Chromiumへのパッチ
** 向き不向きがある

##(p) なぜPDF処理(2) 

* Chromiumへのパッチ vs 後処理
** 本家に取り込まれない場合は追従がしんどい
* 後処理でできることは後処理で

#(t) PDF後処理: 要件

##(t) 組み込んで配布
##(t) PDF細かく触れる
##(t) Win/Linux/macOS
##(t) C++から呼びたい
##(t) C++ 書きたくない
p.center: (できれば)

# lopdf

* バイナリに組み込める。または簡単に一緒に配布できる
* PDFの低レイヤが触れる
* Linux/Windows/macOSのx86_64
* C++から呼べる
* Rustで書ける

#(t) 懸念
section.page.no-h {
* PDF操作の機能が本当に足りているか
* C++からの呼び出し
** そこそこ複雑な構造を渡すインタフェース
* ちゃんとRustのコードが書けるのか (私が）
}

#(t) 機能が足りているか
section.page.no-h {
* 結論から言うと、足りている。
* ただし低レイヤなのでコード量は多い
* 抽象度の高いRubyのPrawnとコードを比較してみる。
}

##(p) 機能比較(1)

* Hello World

###(p) Prawn

###(p) lopdf

##(p) 機能比較(2)

* Outlines (PDFしおり)

###(p) Prawn

###(p) lopdf

##(t) C++から呼び出し
section.page.no-h {
* PDFしおり
** ラベル、階層、ページ番号
*** の配列
}

###(t) 手段１
section.page.no-h {
* 新規Vectorへのポインタを返すAPI
* Vectorとデータの組みを渡して、Vectorに追加していくAPI
* VectorとPDFへのファイルパスを渡して、書き込むAPI
}

###(t) 手段1の実現
section.page.no-h {
* 元々はJSで、オブジェクトの配列
* C++のデータ構造にまず変換
* C++上でさらにRustで実装したAPIを呼びだす
}

###(t) だるい

###(p) 手段1の欠点

* C++コード上で構造を作る必要がある
** 中間に入るC++のコードでは、本来構造を知らなくても良い

###(t) 手段2
section.page.no-h {
* JSONを使う
** JS側でJSON文字列に変換
** C++ではその文字列をそのままRustで書いたAPIへ
** Rust側ではJSONをパースしてVectorを作る
}

##(t) 今回は手段2を採用

#(t) デモ


